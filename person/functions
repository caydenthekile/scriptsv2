local gamenamee = 'Preset'
local plyfake = game.Players.LocalPlayer
local charfake = plyfake.Character or plyfake.CharacterAdded:Wait()
local rootfake = charfake:WaitForChild('HumanoidRootPart')
local threadsfake = {}
local connectionsfake = {}
getgenv().funcs = {
     threads = threadsfake,
     connections = connectionsfake,
     gamename = gamenamee,
     queue_on_teleport = queue_on_teleport or syn and syn.queue_on_teleport or fluxus and fluxus.queue_on_teleport,
     httprequest = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request,
     gamespecific = function()
          return "W.o.U's Custom Folder//"..'UI Configs//'..game.Players.LocalPlayer.Name.."_"..funcs.gamename.."_".."autosave.json"
     end,
     ply = plyfake,
     char = charfake,
     root = rootfake,
     isalivecheck = function()
          local exists, part = pcall(function()
               return funcs.char.Humanoid
          end)
          if exists then
               if part.Health > 0 then
                    return true
               else
                    return false
               end
          else
               return false
          end
     end,
     float = function(val)
          local newvel = Instance.new('BodyVelocity')
          newvel.Name = 'idkkkk'
          newvel.Velocity = Vector3.new(0, 0, 0)
          if funcs.isalivecheck() then
               if val then
                    if not funcs.root:FindFirstChild(newvel.Name) then
                         newvel.Parent = funcs.root
                    end
               elseif not val or val == nil then
                    if funcs.root:FindFirstChild(newvel.Name) then
                         funcs.root:FindFirstChild(newvel.Name):Destroy()
                    end
               end
          end
     end,
     noclip = function(val)
          for _,part in ipairs(funcs.char:GetDescendants()) do
               if part:IsA("BasePart") then
                    part.CanCollide = not val
               end
          end
     end,
     returndist = function(part)
         local dist
          if funcs.isalivecheck() then
               if funcs.root then
                    dist = (funcs.root.Position - part.Position).Magnitude
               end
          end
         return dist
     end,
     tp = function(place)
          if funcs.isalivecheck() then
               funcs.root.CFrame = place.CFrame
          end
     end,
     generateNumbers = function(count)
         local numbers = {}
         local interval = 1 / (count - 1)  -- Adjusted to exclude zero
         for i = 0, count - 1 do
             local number = interval * i
             if number ~= 0 then
                 table.insert(numbers, number)
             end
         end
         return numbers
     end,
     tpsafe = function(place,speed)
          local duration = (game.Players.LocalPlayer.Character:WaitForChild('HumanoidRootPart').Position - place.Position).Magnitude/speed
          local tweenInfo = TweenInfo.new(duration,Enum.EasingStyle.Linear)
          local tween = game:GetService('TweenService'):Create(funcs.root,tweenInfo,{CFrame = place})
          funcs.noclip(true)
          funcs.float(true)
          tween:Play()
     end,
     espadd = function(item, name, toggle, color)
          if item.ClassName == 'Model' then
               local dist = (funcs.root.Position - item:GetModelCFrame().Position).Magnitude
               local spot, vis = workspace.CurrentCamera:WorldToViewportPoint(item:GetModelCFrame().Position)
               local esp = {}
               esp.name = Drawing.new('Text')
               esp.name.Text = name
               esp.name.Size = 10
               esp.name.Position = Vector2.new(spot.X - 35, spot.Y)
               esp.name.Visible = false
               esp.name.Color = WoUStuff[color]
               local espthread1 = task.spawn(function()
                    while true and task.wait() do
                         if not item then
                              esp.name:Remove()
                              task.cancel(funcs.threads.espthread1)
                         end
                         local spott, viss = workspace.CurrentCamera:WorldToViewportPoint(item:GetModelCFrame().Position)
                         if viss then
                              setrenderproperty(esp.name, "Visible", WoUStuff[toggle])
                              setrenderproperty(esp.name, 'Color', WoUStuff[color])
                              setrenderproperty(esp.name, 'Position', Vector2.new(spott.X - 35, spott.Y))
                         elseif not viss then
                              setrenderproperty(esp.name, "Visible", false)
                         end
                    end
               end)
               esp.distance = Drawing.new('Text')
               esp.distance.Text = math.round(dist)
               esp.distance.Position = Vector2.new(spot.X - 5, spot.Y + 10)
               esp.distance.Visible = false
               esp.distance.Size = 10
               esp.distance.Color = WoUStuff[color]
               local espthread2 = task.spawn(function()
                    while true and task.wait() do
                         if not item then
                              esp.distance:Remove()
                              task.cancel(funcs.threads.espthread2)
                         end
                         local distt = (funcs.root.Position - item:GetModelCFrame().Position).Magnitude
                         local spott, viss = workspace.CurrentCamera:WorldToViewportPoint(item:GetModelCFrame().Position)
                         if viss then
                              setrenderproperty(esp.distance, "Visible", WoUStuff[toggle])
                              setrenderproperty(esp.distance, 'Color', WoUStuff[color])
                              setrenderproperty(esp.distance, "Text", math.round(distt))
                              setrenderproperty(esp.distance, 'Position', Vector2.new(spott.X - 5, spott.Y + 10))
                         elseif not viss then
                              setrenderproperty(esp.distance, "Visible", false)
                         end
                    end
               end)
               table.insert(funcs.threads, espthread1)
               table.insert(funcs.threads, espthread2)
          elseif item.ClassName == 'Part' then
               local dist = (funcs.root.Position - item.Position).Magnitude
               local spot = workspace.CurrentCamera:WorldToViewportPoint(item.Position)
               local esp = {}
               esp.name = Drawing.new('Text')
               esp.name.Text = name
               esp.name.Size = 10
               esp.name.Position = Vector2.new(spot.X - 35, spot.Y)
               esp.name.Visible = false
               esp.name.Color = WoUStuff[color]
               local espthread3 = task.spawn(function()
                    while true and task.wait() do
                         if not item then
                              esp.name:Remove()
                              task.cancel(funcs.threads.espthread3)
                         end
                         local spott,viss = workspace.CurrentCamera:WorldToViewportPoint(item.Position)
                         if viss then
                              setrenderproperty(esp.name,"Visible",WoUStuff[toggle])
                              setrenderproperty(esp.name,'Color',WoUStuff[color])
                              setrenderproperty(esp.name,'Position',Vector2.new(spott.X-35,spott.Y))
                         elseif not viss then
                              setrenderproperty(esp.name,"Visible",false)
                         end
                    end
               end)
               esp.distance = Drawing.new('Text')
               esp.distance.Text = math.round(dist)
               esp.distance.Position = Vector2.new(spot.X-5,spot.Y+10)
               esp.distance.Visible = false
               esp.distance.Size = 10
               esp.distance.Color = WoUStuff[color]
               local espthread4 = task.spawn(function()
                    while true and task.wait() do
                         if not item then
                              esp.distance:Remove()
                              task.cancel(funcs.threads.espthread4)
                         end
                         local distt = (funcs.root.Position - item.Position).Magnitude
                         local spott,viss = workspace.CurrentCamera:WorldToViewportPoint(item.Position)
                         if viss then
                              setrenderproperty(esp.distance,"Visible",toggle)
                              setrenderproperty(esp.distance,"Color",color)
                              setrenderproperty(esp.distance,"Text",math.round(distt))
                              setrenderproperty(esp.distance,'Position',Vector2.new(spott.X-5,spott.Y+10))
                         elseif not viss then
                              setrenderproperty(esp.distance,"Visible",false)
                         end
                    end
               end)
               table.insert(funcs.threads,espthread3)
               table.insert(funcs.threads,espthread4)
          end
     end,
     servhop = function()
          local servs = {}
          local req = funcs.httprequest({
              Url = string.format("https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Asc&limit=100", game.placeId)
          })
          local body = game:GetService('HttpService'):JSONDecode(req.Body)
          for i, v in next, body.data do
              if tonumber(v.playing) < tonumber(v.maxPlayers) and v.id ~= game.JobId then
                  table.insert(servs, v.id)
              end
          end
          if #servs > 0 then
               local worked, code = pcall(function()
                    game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, servs[math.random(1, #servs)],funcs.ply)
               end)
               if not worked then
                    funcs.servhop()
               end
          else
              funcs.servhop()
          end
     end,
     rj = function()
          local worked, err = pcall(function()
              game:GetService('TeleportService'):Teleport(game.PlaceId, funcs.ply)
          end)
          if not worked then
              funcs.rj()
          end
     end,
     send = function(what, where)
          funcs.httprequest({
              Url = where,
              Method = "POST",
              Headers = {
                  ["Content-Type"] = "application/json"
              },
              Body = game:GetService("HttpService"):JSONEncode({
                  ["content"] = what
              })
          })
     end
}
local new = {
     __index = function(table,index)
          if index == 'root' then
               table['root'] = funcs.char:WaitForChild('HumanoidRootPart')
          end
     end
}
setmetatable(funcs,new)
return funcs
